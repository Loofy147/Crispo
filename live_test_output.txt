ðŸš€ ====================================================================
ORCHESTRATOR AI: AUTONOMOUS EXECUTION
Project: AutoCode_Genesis
Objective: Generate a learning-augmented algorithm for the ski rental problem
======================================================================
  [MetaLearner] No history for project type, using default strategy.
ðŸ§  Meta-Learner Strategy: GA Gens=5, RL Eps=2

ðŸ“Š PHASE 1: Genetic Algorithm Evolution
  [GA] Gen 1: Best Fitness=2.943, Avg Fitness=2.632
  [GA] Gen 2: Best Fitness=2.943, Avg Fitness=2.756
  [GA] Gen 3: Best Fitness=2.943, Avg Fitness=2.831
  [GA] Gen 4: Best Fitness=2.962, Avg Fitness=2.887
  [GA] Gen 5: Best Fitness=2.962, Avg Fitness=2.923

ðŸŽ¯ PHASE 2: Reinforcement Learning Fine-Tuning
  [RL] Episode 1: Reward=5.763, Epsilon=1.000
  [RL] Episode 2: Reward=5.838, Epsilon=0.995

ðŸ’» PHASE 3: Pipeline Generation and Execution
  - Generating a complete LAA Solution Package (Algorithm + Predictor)...
  - Solution Package saved to generated_algorithm.py and generated_predictor.py

ðŸ”¬ PHASE 4: Verification and Feedback
  [Registry] Saved ski_rental solution v1 to registry.
  [Registry] Saved solution for ski_rental with competitive ratio: 1.0
  - Co-Designed Solution Competitive Ratio: 1.00

======================================================================
ORCHESTRATION COMPLETE
======================================================================

--- Layer 0 ---

"""
Learning-Augmented Algorithm for the Ski Rental Problem
"""
import sys
import json

def ski_rental_algorithm(B, prediction_interval, trust_lambda, actual_days):
    """
    Executes the UQ-aware learning-augmented ski rental algorithm.

    Args:
        B (int): The cost to buy skis.
        prediction_interval (List[int]): The predicted [lower, upper] bound
            of skiing days.
        trust_lambda (float): The trust parameter (lambda) between 0 and 1.
        actual_days (int): The actual number of skiing days.

    Returns:
        int: The total cost incurred by the algorithm.
    """
    # Use the upper bound of the interval for a more robust threshold
    prediction_upper_bound = prediction_interval[1]

    # The core of the learning-augmented algorithm: a blended threshold
    threshold = (1 - trust_lambda) * B + trust_lambda * min(prediction_upper_bound, B)

    cost = 0
    bought_skis = False
    for day in range(1, actual_days + 1):
        if day >= threshold and not bought_skis:
            cost += B
            bought_skis = True
            break
        else:
            cost += 1 # Rent for the day

    # If we never bought, the total cost is just the number of days we rented
    if not bought_skis:
        cost = actual_days

    return cost

def calculate_optimal_cost(B, actual_days):
    """Calculates the optimal offline cost."""
    return min(B, actual_days)

def main():
    """Main execution function."""
    if len(sys.argv) != 5:
        print("Usage: python ski_rental.py <buy_cost> '<prediction_interval>' <trust_lambda> <actual_days>")
        sys.exit(1)

    B = int(sys.argv[1])
    prediction_interval = json.loads(sys.argv[2])
    trust_lambda = float(sys.argv[3])
    actual_days = int(sys.argv[4])

    alg_cost = ski_rental_algorithm(B, prediction_interval, trust_lambda, actual_days)
    opt_cost = calculate_optimal_cost(B, actual_days)

    output = {
        "algorithm_cost": alg_cost,
        "optimal_cost": opt_cost,
        "competitive_ratio": alg_cost / opt_cost if opt_cost > 0 else 1
    }
    print(json.dumps(output))

if __name__ == "__main__":
    main()


--- Layer 1 ---

"""
Time-Series Predictor for Learning-Augmented Algorithms
"""
import sys
import json
import pandas as pd
from statsmodels.tsa.arima.model import ARIMA

class Predictor:
    def __init__(self, historical_data_path: str):
        self.historical_data_path = historical_data_path
        self.model = self._train()

    def _train(self):
        """Trains a simple ARIMA model."""
        try:
            data = pd.read_csv(self.historical_data_path)
            series = data['value']
            model = ARIMA(series, order=(5, 1, 0))
            return model.fit()
        except Exception as e:
            print(f"Predictor training failed: {e}", file=sys.stderr)
            return None

    def predict_interval(self, steps: int = 1):
        """
        Outputs a UQ prediction interval for a number of future steps.

        Args:
            steps (int): The number of future steps to predict.

        Returns:
            List[int]: A [lower_bound, upper_bound] prediction interval.
        """
        if not self.model:
            # Fallback on training failure
            return [10, 20]

        try:
            forecast = self.model.get_forecast(steps=steps)
            pred_ci = forecast.conf_int().iloc[-1] # Get the last CI for multi-step

            lower_bound = int(pred_ci[0])
            upper_bound = int(pred_ci[1])

            # Ensure bounds are reasonable
            lower_bound = max(1, lower_bound)
            upper_bound = max(lower_bound, upper_bound)

            return [lower_bound, upper_bound]
        except Exception as e:
            print(f"Predictor prediction failed: {e}", file=sys.stderr)
            return [10, 20] # Fallback

def main():
    """Main execution function for command-line use."""
    if len(sys.argv) != 2:
        print("Usage: python predictor.py <historical_data_path>")
        sys.exit(1)

    historical_data_path = sys.argv[1]
    predictor = Predictor(historical_data_path)
    prediction_interval = predictor.predict_interval()
    print(json.dumps(prediction_interval))

if __name__ == "__main__":
    main()
