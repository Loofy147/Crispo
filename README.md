# OrchestratorAI

## Purpose

OrchestratorAI is an autonomous system designed to translate high-level human objectives into functional, multi-layer software pipelines. It leverages a combination of artificial intelligence techniques to autonomously design, generate, verify, and learn from its own code. The primary goal of this project is to explore the potential of AI as an autonomous software engineer, capable of solving complex problems by composing and orchestrating multiple software components.

## Architecture Overview

The system is architected as a pipeline of intelligent agents, each responsible for a specific phase of the software development lifecycle:

1.  **Meta-Learning**: The `MetaLearner` analyzes the user's objective and, based on past experience, selects an optimal strategy for the subsequent AI components. It uses an epsilon-greedy exploration strategy to balance exploiting known-good strategies with exploring new ones.
2.  **Genetic Algorithm (GA)**: The `GAOptimizer` takes a set of base parameters and evolves them over several generations to find a robust starting point for the code generation process.
3.  **Reinforcement Learning (RL)**: The `RLAgent` then fine-tunes these parameters, using a Q-learning algorithm to optimize them for the specific task.
4.  **Intent-Driven Code Generation**: The `CodeGenerator` uses the final, optimized parameters to generate a series of scripts. Critically, it uses keyword matching on the user's objective to select the most logically appropriate code template for each layer of the pipeline.
5.  **Pipeline Verification**: The `Verifier` performs a true end-to-end integration test of the generated pipeline. It executes the scripts in sequence, passing the output of each layer as the input to the next, to provide a high-fidelity assessment of the pipeline's quality.
6.  **Self-Correction**: The results of the verification are fed back into the `MetaLearner`, closing the loop and enabling the system to learn from its successes and failures.

## Core Components

- **GAOptimizer**: Evolves layer configurations using a genetic algorithm.
- **RLAgent**: Fine-tunes parameters using a Q-learning agent.
- **AttentionRouter**: Allows for communication and dependency between script layers.
- **CodeGenerator**: Generates multi-layer scripts from a set of parameters.
- **MetaLearner**: Learns which optimization strategies work best for different task types.

## Advanced Features

- **TransferLearningEngine**: Manages transfer learning from pre-existing script models.
- **NeuralArchitectureSearch**: Performs neural architecture search to find the optimal layer structure.
- **FederatedOptimizer**: Optimizes models using federated learning principles.
- **Production Transfer Learning**: A sophisticated, multi-step pipeline for applying pre-trained models, which was itself generated by OrchestratorAI.

## How to Run

To run the orchestrator, use the following command:

```bash
python3 orchestrator.py [OPTIONS]
```

### Options

- `--project`: The name of the project.
- `--objective`: The main objective of the project.
- `--project_type`: The type of the project (e.g., 'data_pipeline', 'web_scraper').
- `--domain`: The domain of the project.
- `--complexity`: The complexity of the project (0.0 to 1.0).
- `--load-metaknowledge`: Path to load MetaLearner state from.
- `--save-metaknowledge`: Path to save MetaLearner state to.
- `--enable-transfer-learning`: Enable Transfer Learning.
- `--enable-nas`: Enable Neural Architecture Search.
- `--enable-federated-optimization`: Enable Federated Optimization.
- `--trust-parameter`: The trust parameter (lambda) for learning-augmented algorithms.

## âœ¨ New in v2.0: Learning-Augmented Algorithms

As of v2.0, OrchestratorAI has been upgraded to a powerful framework for designing and evaluating **Learning-Augmented Algorithms (LAA)**, based on the latest research in the field.

You can now use OrchestratorAI to generate self-contained algorithms for classic online problems (like the Ski Rental problem) and automatically evaluate their core performance guarantees:
- **Consistency:** How well the algorithm performs with perfect ML predictions.
- **Robustness:** How well the algorithm performs with worst-case ML predictions.
- **Smoothness:** How gracefully the algorithm's performance degrades as the ML prediction error increases.
- **Brittleness:** A formal check to detect if the algorithm's performance collapses to its worst-case guarantee even with tiny prediction errors.

The system's `Verifier` will automatically evaluate the generated algorithm and output all of these key metrics, which are then recorded by the `MetaLearner`.

### Generating a Full LAA Solution Package

OrchestratorAI has evolved into a full co-design system. When given an LAA objective, it generates a complete **Solution Package**:
1.  **A Predictor Script:** A Python script that trains a time-series model on historical data to produce a real, Uncertainty-Quantified (UQ) prediction.
2.  **An Algorithm Script:** The Learning-Augmented Algorithm, which is designed to consume the UQ prediction from the predictor.

This package is then subjected to a realistic, two-stage "live" evaluation: the predictor is run, and its output is fed directly to the algorithm, giving a true measure of the co-designed system's performance.

#### Example
```bash
# This will generate generated_predictor.py and generated_algorithm.py,
# then run them together to evaluate their combined performance.
python3 orchestrator.py \
    --objective "Generate a learning-augmented algorithm for the ski rental problem" \
    --trust-parameter 0.8 \
    --save-metaknowledge laa_knowledge.pkl
```

### Example

```bash
python3 orchestrator.py \
    --project "MyProject" \
    --objective "Generate a multi-layer script for data analysis" \
    --project_type "data_pipeline" \
    --domain "data_science" \
    --complexity 0.7 \
    --save-metaknowledge metaknowledge.pkl \
    --enable-transfer-learning \
    --enable-nas \
    --enable-federated-optimization
```
